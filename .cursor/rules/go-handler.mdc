---
description: Patterns for Go handler layer files — HTTP request handling, validation, routing
globs: backend/internal/handler/*.go
alwaysApply: false
---

# Go Handler Layer Patterns

Follow the established patterns in `auth.go` and `user.go`.

## Structure

```go
type XHandler struct { xService xServicer }
func NewXHandler(xService *service.XService) *XHandler { ... }
```

- Handlers are thin — validate input, delegate to service, return JSON.
- No business logic in handlers. No direct DB access.
- **Struct field is the interface** (`xServicer`), constructor takes the concrete type. This is the standard pattern — `make new-module` generates it automatically.

## Service Interfaces

Handlers use unexported interfaces (`authServicer`, `userServicer`, `sseHubber`), not concrete service types. This enables mock-based testing. Constructor takes concrete types (callers unchanged), struct field is the interface. See `handler/interfaces.go`.

## Scaffold Output

`make new-module name=items` generates:
- `handler/item.go` — Handler with interface-typed service field
- `handler/item_test.go` — Mock struct + 5 test stubs (Create success, Create validation, List, GetByID not found, Delete)
- Interface entry appended to `handler/interfaces.go`
- Fill in test bodies for your specific validation logic and error paths.

## Auth Extraction

Every protected handler starts with:

```go
userID, err := requireUserID(c)
if err != nil { return err }
userType, err := requireUserType(c)
if err != nil { return err }
```

Role guards (when needed) go after extraction:

```go
if userType != "admin" {
    return apperror.Forbidden("Only admins can create items")
}
```

Resource-level authorization is handled by the service layer, not the handler.

## Request Binding

```go
var req CreateXRequest
if err := c.Bind(&req); err != nil {
    return apperror.BadRequest("Invalid request body")
}
```

Define request structs with `json` tags in the same handler file.

## Validation

Simple validations in the handler (required fields). Complex validations in a `validateX` function:

```go
func validateCreateItem(req *CreateItemRequest) error {
    details := make(map[string]string)
    if req.Title == "" { details["title"] = "Title is required" }
    if len(details) > 0 {
        return apperror.Validation("Validation failed", details)
    }
    return nil
}
```

## Response Codes

- `201 Created` for POST that creates a resource
- `200 OK` for GET, PUT, POST actions (publish, approve, etc.)
- `200 OK` with `{"message": "..."}` for DELETE

## Error Responses

Always use `apperror` — never `echo.NewHTTPError`:

```go
// BAD
return echo.NewHTTPError(http.StatusForbidden, "not allowed")
// GOOD
return apperror.Forbidden("not allowed")
```

## Route Registration

In `cmd/server/main.go`:
1. Create service in the services block
2. Create handler in the handlers block
3. Register routes on the `protected` group

```go
// in main():
xService := service.NewXService(pool)
xHandler := handler.NewXHandler(xService)
// ...
protected.POST("/x", xHandler.Create)
protected.GET("/x", xHandler.List)
protected.GET("/x/:id", xHandler.GetByID)
```

## Query Parameter Parsing

Always validate query params. Never ignore `strconv` errors:

```go
// BAD — silent invalid page
page, _ := strconv.Atoi(c.QueryParam("page"))

// GOOD — default on error
page, err := strconv.Atoi(c.QueryParam("page"))
if err != nil || page < 1 { page = 1 }
perPage, err := strconv.Atoi(c.QueryParam("per_page"))
if err != nil || perPage < 1 || perPage > 100 { perPage = 20 }
```

For enum-like string params, validate against allowed values:

```go
status := c.QueryParam("status")
if status != "" && status != "active" && status != "completed" {
    return apperror.BadRequest("Invalid status filter")
}
```
