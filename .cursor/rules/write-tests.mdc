---
description: Patterns for writing tests — integration tests with TestDB, unit tests for pure logic, test data seeding
globs:
  - backend/**/*_test.go
  - frontend/**/*.test.{ts,tsx}
  - frontend/tests/e2e/*.spec.ts
alwaysApply: false
---

# Writing Tests

## Integration Tests (Service Layer)

Test real SQL against a real PostgreSQL instance using `testutil.WithTestDB`.

```go
//go:build integration

package service_test

import (
    "testing"
    "github.com/golid-ai/golid/backend/internal/service"
    "github.com/golid-ai/golid/backend/internal/testutil"
)

func TestItemService_Create(t *testing.T) {
    testutil.WithTestDB(t, func(pool *pgxpool.Pool) {
        svc := service.NewItemService(pool, 20, 100)

        // Seed prerequisite data with raw SQL
        _, err := pool.Exec(ctx, `INSERT INTO users (...) VALUES (...)`)
        // ...

        // Test the service method
        result, err := svc.Create(ctx, &service.CreateItemInput{...})
        if err != nil { t.Fatalf("expected no error, got %v", err) }
        if result.Title != "Test Item" { t.Errorf("expected title 'Test Item', got %s", result.Title) }
    })
}
```

### Key Rules

- **Build tag**: `//go:build integration` at the top of the file.
- **File naming**: `x_integration_test.go` (not `x_test.go`) to make it clear.
- **Seed with raw SQL**: Use `pool.Exec` with INSERT statements. Never use service methods to seed — they have their own validation and side effects.
- **Test one thing per function**: Each test function should test one behavior (happy path, error case, permission check, etc.).
- **Clean state**: `WithTestDB` provides a fresh database for each test. No cleanup needed.

### What to Test

- **Happy paths**: Create, Read, Update, Delete with valid inputs.
- **Permission checks**: Wrong user type, non-owner, non-member. Expect `FORBIDDEN`.
- **Status guards**: Operation on wrong-status parent. Expect `BAD_REQUEST`.
- **Not found**: Non-existent ID. Expect `NOT_FOUND`.
- **Conflict**: Duplicate entries. Expect `CONFLICT`.
- **Edge cases**: Empty arrays, null optional fields, boundary values.

Reference: existing `_integration_test.go` files in `backend/internal/service/`

## Unit Tests (Pure Logic)

For validation helpers, parsing functions, and other pure logic — no build tag needed.

```go
package service

import "testing"

func TestNormalizePagination(t *testing.T) {
    tests := []struct {
        page, perPage   int
        wantP, wantPP   int
    }{
        {0, 0, 1, 20},
        {-1, 200, 1, 20},
        {5, 10, 5, 10},
    }
    for _, tt := range tests {
        p, pp := NormalizePagination(tt.page, tt.perPage, 20, 100)
        if p != tt.wantP || pp != tt.wantPP {
            t.Errorf("NormalizePagination(%d, %d) = (%d, %d), want (%d, %d)",
                tt.page, tt.perPage, p, pp, tt.wantP, tt.wantPP)
        }
    }
}
```

### Key Rules

- **No build tag** — runs on every `go test`.
- **Same package** — test unexported functions directly (e.g., `NormalizePagination`).
- **Table-driven tests** — use `[]struct` pattern for multiple cases.
- **File naming**: `x_test.go` in the same directory as the code.

Reference: existing `_test.go` files in `backend/internal/service/`

## Mock-based Handler Tests

Create a mock struct implementing the service interface. Set function fields for methods under test. Unimplemented methods panic. Inject mock directly into handler struct: `h := &AuthHandler{authService: &mockAuthService{...}}`. See `handler/auth_test.go` for examples.

## Scaffold-Generated Tests

`make new-module name=items` automatically generates `handler/item_test.go` with:

- A `mockItemService` struct implementing the `itemServicer` interface
- A `testItemDetail()` helper returning sample data
- 5 test stubs: Create success, Create validation error, List, GetByID not found, Delete

After scaffolding, fill in test bodies for your specific validation rules, error paths, and edge cases. The generated tests follow the same pattern as `auth_test.go`.

## Always Test Error Paths

Don't just test happy paths. Every service method should have tests for:

- **Permission denied** — wrong user type, non-owner, non-member → expect `FORBIDDEN`
- **Invalid status** — operation on wrong-status entity → expect `BAD_REQUEST`
- **Not found** — non-existent ID → expect `NOT_FOUND`
- **Duplicate/conflict** — re-creating existing entity → expect `CONFLICT`

These are the bugs that slip through manual testing and break in production.

## Component Unit Tests (SolidJS)

Use `@solidjs/testing-library` for component-level tests. Test the public API: renders, accepts props, fires events.

```tsx
import { render, screen, fireEvent } from "@solidjs/testing-library";
import { Button } from "./Button";

test("calls onClick", async () => {
  const handler = vi.fn();
  render(() => <Button onClick={handler}>Click</Button>);
  await fireEvent.click(screen.getByText("Click"));
  expect(handler).toHaveBeenCalledTimes(1);
});
```

Place test files next to the component: `Button.test.tsx` alongside `Button.tsx`. Vitest discovers `src/**/*.test.{ts,tsx}` automatically.

**Important:** `vitest.config.ts` must have `resolve.conditions: ["development", "browser"]` to prevent Solid from resolving server-side bundles in jsdom.

### Test Quality Bar

Every component test must assert at least one **behavioral property**, not just existence. "Renders without crashing" is not a test.

```tsx
// BAD — tests nothing meaningful
test("renders", () => {
  const { container } = render(() => <Alert variant="success" message="Done" />);
  expect(container).toBeTruthy();
});

// GOOD — tests actual behavior: correct variant class, message rendered, dismiss works
test("renders success variant with message", () => {
  render(() => <Alert variant="success" message="Done" />);
  expect(screen.getByText("Done")).toBeInTheDocument();
  expect(screen.getByRole("alert")).toHaveClass("bg-green");
});

test("calls onDismiss when close button clicked", async () => {
  const onDismiss = vi.fn();
  render(() => <Alert message="Done" onDismiss={onDismiss} />);
  await fireEvent.click(screen.getByRole("button"));
  expect(onDismiss).toHaveBeenCalledTimes(1);
});
```

**Minimum assertions per component test file:**
- Renders with required props and shows expected content
- Variant/size/state props produce correct visual output (classes, attributes)
- Callbacks fire when expected (onClick, onDismiss, onChange, etc.)
- Accessibility: `axe(container)` passes with no violations (where feasible in jsdom)

**jsdom limitations** — skip or mark as smoke-test-only:
- SVG measurement APIs (`getBBox`, `getScreenCTM`) return zeros — Observable Plot/D3 chart tests can only verify render-without-crash
- `getUserMedia`, `MediaRecorder`, WebGL — not available in jsdom, need E2E
- Drag-and-drop (`pointermove` sequences) — unreliable in jsdom, need E2E

### Coverage Thresholds

After writing tests, update `vitest.config.ts` thresholds to 5% below the new actual coverage. This prevents regression without blocking future work. Ratchet up as coverage grows.

Current thresholds: `statements: 80, branches: 84, functions: 77, lines: 80`. CI fails if coverage drops below these.

### Pre-Push Checklist

Before pushing any test file changes, run both:

```bash
cd frontend && npx vitest run          # runtime tests
cd frontend && npx tsc --noEmit        # type checking
```

TypeScript catches import errors (non-existent exports, using types as values) that JavaScript silently ignores at runtime. CI runs `npm run typecheck` and will reject type errors even when all tests pass.

## E2E Tests (Playwright)

E2E tests live in `frontend/tests/e2e/`. They require the full stack running (backend + DB + frontend).

### SPA Navigation — Wait for Page Content, Not URLs

SolidJS uses client-side routing (`pushState`). Playwright's `waitForURL` waits for a browser `load` event that never fires during SPA navigation. **Always wait for page content instead.**

```typescript
// BAD — hangs forever on SPA navigation
await page.click('button[type="submit"]');
await page.waitForURL("**/dashboard", { timeout: 15000 });

// GOOD — waits for actual rendered content
await page.click('button[type="submit"]');
await expect(page.getByRole("heading", { name: "Dashboard" })).toBeVisible({
  timeout: 15000,
});
```

### Login Verification — Use Dashboard-Specific Content

The login page shows "Welcome back" as its heading. **Never use `/welcome/i` to verify login succeeded** — it matches the login page text immediately, before login actually completes.

```typescript
// BAD — matches "Welcome back" on the login page itself
await expect(page.getByText(/welcome/i)).toBeVisible();

// GOOD — "Dashboard" h1 only exists on the dashboard page
await expect(page.getByRole("heading", { name: "Dashboard" })).toBeVisible({
  timeout: 15000,
});
```

### Strict Mode Violations

When text appears in multiple elements (navbar, heading, footer), use role-based selectors:

```typescript
// BAD — "Golid" appears in navbar, h1, and footer
await expect(page.getByText("Golid")).toBeVisible();

// GOOD — targets the specific heading
await expect(page.getByRole("heading", { name: "Golid" })).toBeVisible();
```

### Form Validation

SolidJS signals may not settle instantly after `fill()`. Wait for the submit button to be enabled before clicking:

```typescript
await page.fill('[placeholder="Create a password"]', "password123");
await page.fill('[placeholder="Confirm your password"]', "password123");
await expect(page.locator('button[type="submit"]')).toBeEnabled({
  timeout: 5000,
});
await page.click('button[type="submit"]');
```

When testing client-side validation that disables submit, assert `toBeDisabled()` — don't try to click:

```typescript
// BAD — click waits forever for a disabled button to enable
await page.click('button[type="submit"]');

// GOOD — asserts the validation state directly
await expect(page.locator('button[type="submit"]')).toBeDisabled();
```

### Input Values

Playwright has no `getByDisplayValue`. Use `locator` + `toHaveValue`:

```typescript
// BAD — this method doesn't exist in Playwright
await expect(page.getByDisplayValue("user@example.com")).toBeVisible();

// GOOD
await expect(page.locator("#email")).toHaveValue("user@example.com");
```

### Buttons vs Headings with Same Text

When a heading and button share the same text (e.g., "Change Password" as both h2 and button), `page.click("text=Change Password")` may click the heading (no-op). Use role selectors:

```typescript
// BAD — may click the h2 heading instead of the button
await page.click("text=Change Password");

// GOOD — targets only the button
await page.getByRole("button", { name: "Change Password" }).click();
```

### Serial Execution (workers: 1)

E2E tests run with `workers: 1` and `fullyParallel: false`. Auth endpoints use strict rate limiting (`AUTH_RATE_LIMIT`, default 5 req/min). Parallel workers exhaust the limit instantly. The dev `docker-compose.yml` sets `AUTH_RATE_LIMIT: 100` but serial execution remains the safest default for tests sharing a mutable database.

### Signup Input Types

The signup form uses `type="text"` with `inputmode="email"` (not `type="email"`). Use placeholder selectors:

```typescript
// BAD — won't match signup email input
page.locator('input[type="email"]');

// GOOD — works on both login (type=email) and signup (type=text)
page.locator('[placeholder="you@example.com"]');
```

## Running Tests

```bash
# Backend unit tests (fast, no DB needed)
cd backend && go test ./...

# Backend integration tests (requires running PostgreSQL)
cd backend && go test -tags=integration ./...

# Frontend unit + component tests
cd frontend && npm test

# Frontend type check (run before pushing — catches import errors tests miss)
cd frontend && npx tsc --noEmit

# E2E tests (requires full stack running)
cd frontend && npx playwright install chromium  # first time only
cd frontend && npx playwright test
```
