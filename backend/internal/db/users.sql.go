// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearPasswordResetToken = `-- name: ClearPasswordResetToken :exec
UPDATE users
SET password_reset_selector = NULL,
    password_reset_verifier_hash = NULL,
    password_reset_expires = NULL
WHERE id = $1
`

func (q *Queries) ClearPasswordResetToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearPasswordResetToken, id)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, type)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash
`

type CreateUserParams struct {
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	Type         interface{} `json:"type"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash, arg.Type)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const createUserWithVerification = `-- name: CreateUserWithVerification :one

INSERT INTO users (email, password_hash, type, verification_selector, verification_verifier_hash)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash
`

type CreateUserWithVerificationParams struct {
	Email                    string      `json:"email"`
	PasswordHash             string      `json:"password_hash"`
	Type                     interface{} `json:"type"`
	VerificationSelector     pgtype.Text `json:"verification_selector"`
	VerificationVerifierHash pgtype.Text `json:"verification_verifier_hash"`
}

// ============================================================================
// EMAIL VERIFICATION (selector.verifier pattern)
// ============================================================================
func (q *Queries) CreateUserWithVerification(ctx context.Context, arg CreateUserWithVerificationParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUserWithVerification,
		arg.Email,
		arg.PasswordHash,
		arg.Type,
		arg.VerificationSelector,
		arg.VerificationVerifierHash,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

// Available for account deletion feature â€” not yet wired to a handler.
func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash FROM users WHERE id = $1
`

// ============================================================================
// USERS
// ============================================================================
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const getUserByResetSelector = `-- name: GetUserByResetSelector :one

SELECT id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash FROM users
WHERE password_reset_selector = $1
  AND password_reset_expires > NOW()
`

// ============================================================================
// PASSWORD RESET (selector.verifier pattern)
// ============================================================================
func (q *Queries) GetUserByResetSelector(ctx context.Context, passwordResetSelector pgtype.Text) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByResetSelector, passwordResetSelector)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const getUserByVerificationSelector = `-- name: GetUserByVerificationSelector :one
SELECT id, email, password_hash, type, email_verified, first_name, last_name, avatar_url, created_at, updated_at, password_reset_selector, password_reset_verifier_hash, password_reset_expires, verification_selector, verification_verifier_hash FROM users WHERE verification_selector = $1
`

func (q *Queries) GetUserByVerificationSelector(ctx context.Context, verificationSelector pgtype.Text) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByVerificationSelector, verificationSelector)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Type,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordResetSelector,
		&i.PasswordResetVerifierHash,
		&i.PasswordResetExpires,
		&i.VerificationSelector,
		&i.VerificationVerifierHash,
	)
	return &i, err
}

const setPasswordResetToken = `-- name: SetPasswordResetToken :exec
UPDATE users
SET password_reset_selector = $2,
    password_reset_verifier_hash = $3,
    password_reset_expires = $4
WHERE id = $1
`

type SetPasswordResetTokenParams struct {
	ID                        uuid.UUID          `json:"id"`
	PasswordResetSelector     pgtype.Text        `json:"password_reset_selector"`
	PasswordResetVerifierHash pgtype.Text        `json:"password_reset_verifier_hash"`
	PasswordResetExpires      pgtype.Timestamptz `json:"password_reset_expires"`
}

func (q *Queries) SetPasswordResetToken(ctx context.Context, arg SetPasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, setPasswordResetToken,
		arg.ID,
		arg.PasswordResetSelector,
		arg.PasswordResetVerifierHash,
		arg.PasswordResetExpires,
	)
	return err
}

const setVerificationToken = `-- name: SetVerificationToken :exec
UPDATE users SET verification_selector = $2, verification_verifier_hash = $3 WHERE id = $1
`

type SetVerificationTokenParams struct {
	ID                       uuid.UUID   `json:"id"`
	VerificationSelector     pgtype.Text `json:"verification_selector"`
	VerificationVerifierHash pgtype.Text `json:"verification_verifier_hash"`
}

func (q *Queries) SetVerificationToken(ctx context.Context, arg SetVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, setVerificationToken, arg.ID, arg.VerificationSelector, arg.VerificationVerifierHash)
	return err
}

const updatePasswordAndClearReset = `-- name: UpdatePasswordAndClearReset :exec
UPDATE users
SET password_hash = $2,
    password_reset_selector = NULL,
    password_reset_verifier_hash = NULL,
    password_reset_expires = NULL
WHERE id = $1
`

type UpdatePasswordAndClearResetParams struct {
	ID           uuid.UUID `json:"id"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) UpdatePasswordAndClearReset(ctx context.Context, arg UpdatePasswordAndClearResetParams) error {
	_, err := q.db.Exec(ctx, updatePasswordAndClearReset, arg.ID, arg.PasswordHash)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = $2 WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `json:"id"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}
